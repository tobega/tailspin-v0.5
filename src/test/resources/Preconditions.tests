---Failing precondition throws PreconditionFailed
foo templates
requires <|=3>
1 !
end foo

2 -> foo !
=*TypeError: PreconditionFailed
---Passing precondition works
foo templates
requires <|=3>
1 !
end foo

3 -> foo !
=1
---Failing precondition depends on outer scope value
foo templates
  max is $;
  bar templates
  requires <|..$max>
    1 !
  end bar
  7 -> bar !
end foo

6 -> foo !
=*TypeError: PreconditionFailed
---Passing precondition depends on outer scope value
foo templates
  max is $;
  bar templates
  requires <|..$max>
    1 !
  end bar
  7 -> bar !
end foo

8 -> foo !
=1
---Failing precondition on inline templates
2 -> templates
       requires <|=3>
       1 !
     end !
=*TypeError: PreconditionFailed
---Try on template call inhibits precondition error
foo templates
requires <|=2>
  3!
end foo

[1 -> try foo] !
=[]
---Try on inline template call inhibits precondition error
[1 -> try templates
          requires <|=2>
            3!
          end] !
=[]
---Failing precondition on nested call is not caught
foo templates
requires <|=2>
  3!
end foo

[1 -> try templates
        $ -> foo -> 5 !
      end
] !
=*TypeError: PreconditionFailed
---Failing precondition on internal call is not caught
[1 -> try templates
        $ -> templates
             requires <|=2>
               3!
             end -> 5 !
      end
] !
=*TypeError: PreconditionFailed
---Explicit reject sink causes precondition failure
foo templates
  $ !
  $ -> !REJECT
end foo

1 -> foo !
=*TypeError: PreconditionFailed
---Try on explicit reject inhibits failure
foo templates
  $ -> !REJECT
end foo

[1 -> try foo] !
=[]
---Explicit reject caught by try removes previous output
foo templates
  $ !
  $ -> !REJECT
end foo

[1 -> try foo] !
=[]
---Explicit reject caught by try removes previous state changes
foo templates
  @ set 2;
  bar templates
    @foo set 3;
    $ -> !REJECT
  end bar
  $ -> try bar -> 5 !
  $@ !
end foo

1 -> foo !
=2
---Explicit reject caught on auxiliary method keeps state changes
foo templates
  @ set 2;
  bar auxiliary templates
    @foo set 3;
    $ -> !REJECT
  end bar
  $ -> try bar -> 5 !
  $@ !
end foo

1 -> foo !
=3
---Explicit reject caught on auxiliary method removes previous output
foo templates
  @ set 2;
  bar auxiliary templates
    $ !
    $ -> !REJECT
  end bar
  $ -> try bar -> @ set $;
  $@ !
end foo

1 -> foo !
=2
